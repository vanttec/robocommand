// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: proto/report.proto
// Protobuf C++ Version: 6.32.1

#ifndef proto_2freport_2eproto_2epb_2eh
#define proto_2freport_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6032001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proto_2freport_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2freport_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_proto_2freport_2eproto;
}  // extern "C"
namespace robocommand {
namespace roboboat {
namespace v1 {
enum Color : int;
extern const uint32_t Color_internal_data_[];
enum DeliveryType : int;
extern const uint32_t DeliveryType_internal_data_[];
enum GateType : int;
extern const uint32_t GateType_internal_data_[];
enum ObjectType : int;
extern const uint32_t ObjectType_internal_data_[];
enum PatrolBoatActionType : int;
extern const uint32_t PatrolBoatActionType_internal_data_[];
enum RobotState : int;
extern const uint32_t RobotState_internal_data_[];
enum SignalType : int;
extern const uint32_t SignalType_internal_data_[];
enum TaskType : int;
extern const uint32_t TaskType_internal_data_[];
class Docking;
struct DockingDefaultTypeInternal;
extern DockingDefaultTypeInternal _Docking_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Docking_class_data_;
class GatePass;
struct GatePassDefaultTypeInternal;
extern GatePassDefaultTypeInternal _GatePass_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GatePass_class_data_;
class Heartbeat;
struct HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Heartbeat_class_data_;
class LatLng;
struct LatLngDefaultTypeInternal;
extern LatLngDefaultTypeInternal _LatLng_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LatLng_class_data_;
class ObjectDelivery;
struct ObjectDeliveryDefaultTypeInternal;
extern ObjectDeliveryDefaultTypeInternal _ObjectDelivery_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ObjectDelivery_class_data_;
class ObjectDetected;
struct ObjectDetectedDefaultTypeInternal;
extern ObjectDetectedDefaultTypeInternal _ObjectDetected_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ObjectDetected_class_data_;
class PatrolBoat;
struct PatrolBoatDefaultTypeInternal;
extern PatrolBoatDefaultTypeInternal _PatrolBoat_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PatrolBoat_class_data_;
class Report;
struct ReportDefaultTypeInternal;
extern ReportDefaultTypeInternal _Report_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Report_class_data_;
class SoundSignal;
struct SoundSignalDefaultTypeInternal;
extern SoundSignalDefaultTypeInternal _SoundSignal_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SoundSignal_class_data_;
}  // namespace v1
}  // namespace roboboat
}  // namespace robocommand
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::robocommand::roboboat::v1::Color_internal_data_>
    internal::EnumTraitsImpl::value<::robocommand::roboboat::v1::Color>;
template <>
internal::EnumTraitsT<::robocommand::roboboat::v1::DeliveryType_internal_data_>
    internal::EnumTraitsImpl::value<::robocommand::roboboat::v1::DeliveryType>;
template <>
internal::EnumTraitsT<::robocommand::roboboat::v1::GateType_internal_data_>
    internal::EnumTraitsImpl::value<::robocommand::roboboat::v1::GateType>;
template <>
internal::EnumTraitsT<::robocommand::roboboat::v1::ObjectType_internal_data_>
    internal::EnumTraitsImpl::value<::robocommand::roboboat::v1::ObjectType>;
template <>
internal::EnumTraitsT<::robocommand::roboboat::v1::PatrolBoatActionType_internal_data_>
    internal::EnumTraitsImpl::value<::robocommand::roboboat::v1::PatrolBoatActionType>;
template <>
internal::EnumTraitsT<::robocommand::roboboat::v1::RobotState_internal_data_>
    internal::EnumTraitsImpl::value<::robocommand::roboboat::v1::RobotState>;
template <>
internal::EnumTraitsT<::robocommand::roboboat::v1::SignalType_internal_data_>
    internal::EnumTraitsImpl::value<::robocommand::roboboat::v1::SignalType>;
template <>
internal::EnumTraitsT<::robocommand::roboboat::v1::TaskType_internal_data_>
    internal::EnumTraitsImpl::value<::robocommand::roboboat::v1::TaskType>;
}  // namespace protobuf
}  // namespace google

namespace robocommand {
namespace roboboat {
namespace v1 {
enum RobotState : int {
  STATE_UNKNOWN = 0,
  STATE_KILLED = 1,
  STATE_MANUAL = 2,
  STATE_AUTO = 3,
  RobotState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  RobotState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t RobotState_internal_data_[];
inline constexpr RobotState RobotState_MIN =
    static_cast<RobotState>(0);
inline constexpr RobotState RobotState_MAX =
    static_cast<RobotState>(3);
inline bool RobotState_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int RobotState_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RobotState_descriptor();
template <typename T>
::absl::string_view RobotState_Name(T value) {
  static_assert(::std::is_same<T, RobotState>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RobotState_Name().");
  return RobotState_Name(static_cast<RobotState>(value));
}
template <>
inline ::absl::string_view RobotState_Name(RobotState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RobotState_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool RobotState_Parse(
    ::absl::string_view name, RobotState* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<RobotState>(RobotState_descriptor(), name,
                                           value);
}
enum TaskType : int {
  TASK_UNKNOWN = 0,
  TASK_NONE = 1,
  TASK_ENTRY_EXIT = 2,
  TASK_NAV_CHANNEL = 3,
  TASK_SPEED_CHALLENGE = 4,
  TASK_OBJECT_DELIVERY = 5,
  TASK_DOCKING = 6,
  TASK_SOUND_SIGNAL = 7,
  TaskType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TaskType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TaskType_internal_data_[];
inline constexpr TaskType TaskType_MIN =
    static_cast<TaskType>(0);
inline constexpr TaskType TaskType_MAX =
    static_cast<TaskType>(7);
inline bool TaskType_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int TaskType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TaskType_descriptor();
template <typename T>
::absl::string_view TaskType_Name(T value) {
  static_assert(::std::is_same<T, TaskType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TaskType_Name().");
  return TaskType_Name(static_cast<TaskType>(value));
}
template <>
inline ::absl::string_view TaskType_Name(TaskType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TaskType_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool TaskType_Parse(
    ::absl::string_view name, TaskType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskType>(TaskType_descriptor(), name,
                                           value);
}
enum ObjectType : int {
  OBJECT_UNKNOWN = 0,
  OBJECT_BOAT = 1,
  OBJECT_LIGHT_BEACON = 2,
  OBJECT_BUOY = 3,
  ObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ObjectType_internal_data_[];
inline constexpr ObjectType ObjectType_MIN =
    static_cast<ObjectType>(0);
inline constexpr ObjectType ObjectType_MAX =
    static_cast<ObjectType>(3);
inline bool ObjectType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ObjectType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ObjectType_descriptor();
template <typename T>
::absl::string_view ObjectType_Name(T value) {
  static_assert(::std::is_same<T, ObjectType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ObjectType_Name().");
  return ObjectType_Name(static_cast<ObjectType>(value));
}
template <>
inline ::absl::string_view ObjectType_Name(ObjectType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ObjectType_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ObjectType_Parse(
    ::absl::string_view name, ObjectType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectType>(ObjectType_descriptor(), name,
                                           value);
}
enum Color : int {
  COLOR_UNKNOWN = 0,
  COLOR_YELLOW = 1,
  COLOR_BLACK = 2,
  COLOR_RED = 3,
  COLOR_GREEN = 4,
  Color_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Color_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Color_internal_data_[];
inline constexpr Color Color_MIN =
    static_cast<Color>(0);
inline constexpr Color Color_MAX =
    static_cast<Color>(4);
inline bool Color_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int Color_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Color_descriptor();
template <typename T>
::absl::string_view Color_Name(T value) {
  static_assert(::std::is_same<T, Color>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Color_Name().");
  return Color_Name(static_cast<Color>(value));
}
template <>
inline ::absl::string_view Color_Name(Color value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Color_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool Color_Parse(
    ::absl::string_view name, Color* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Color>(Color_descriptor(), name,
                                           value);
}
enum GateType : int {
  GATE_UNKNOWN = 0,
  GATE_ENTRY = 1,
  GATE_EXIT = 2,
  GATE_SPEED_START = 3,
  GATE_SPEED_END = 4,
  GateType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  GateType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t GateType_internal_data_[];
inline constexpr GateType GateType_MIN =
    static_cast<GateType>(0);
inline constexpr GateType GateType_MAX =
    static_cast<GateType>(4);
inline bool GateType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int GateType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GateType_descriptor();
template <typename T>
::absl::string_view GateType_Name(T value) {
  static_assert(::std::is_same<T, GateType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GateType_Name().");
  return GateType_Name(static_cast<GateType>(value));
}
template <>
inline ::absl::string_view GateType_Name(GateType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GateType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool GateType_Parse(
    ::absl::string_view name, GateType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<GateType>(GateType_descriptor(), name,
                                           value);
}
enum SignalType : int {
  SIGNAL_UNKNOWN = 0,
  SIGNAL_ONE_BLAST = 1,
  SIGNAL_TWO_BLAST = 2,
  SignalType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SignalType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SignalType_internal_data_[];
inline constexpr SignalType SignalType_MIN =
    static_cast<SignalType>(0);
inline constexpr SignalType SignalType_MAX =
    static_cast<SignalType>(2);
inline bool SignalType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int SignalType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SignalType_descriptor();
template <typename T>
::absl::string_view SignalType_Name(T value) {
  static_assert(::std::is_same<T, SignalType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SignalType_Name().");
  return SignalType_Name(static_cast<SignalType>(value));
}
template <>
inline ::absl::string_view SignalType_Name(SignalType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SignalType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool SignalType_Parse(
    ::absl::string_view name, SignalType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignalType>(SignalType_descriptor(), name,
                                           value);
}
enum DeliveryType : int {
  DELIVERY_UNKNOWN = 0,
  DELIVERY_WATER = 1,
  DELIVERY_BALL = 2,
  DeliveryType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DeliveryType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t DeliveryType_internal_data_[];
inline constexpr DeliveryType DeliveryType_MIN =
    static_cast<DeliveryType>(0);
inline constexpr DeliveryType DeliveryType_MAX =
    static_cast<DeliveryType>(2);
inline bool DeliveryType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int DeliveryType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DeliveryType_descriptor();
template <typename T>
::absl::string_view DeliveryType_Name(T value) {
  static_assert(::std::is_same<T, DeliveryType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DeliveryType_Name().");
  return DeliveryType_Name(static_cast<DeliveryType>(value));
}
template <>
inline ::absl::string_view DeliveryType_Name(DeliveryType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DeliveryType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool DeliveryType_Parse(
    ::absl::string_view name, DeliveryType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeliveryType>(DeliveryType_descriptor(), name,
                                           value);
}
enum PatrolBoatActionType : int {
  PATROL_BOAT_ACTION_UNKNOWN = 0,
  PATROL_BOAT_ACTION_STOPPING = 1,
  PATROL_BOAT_ACTION_RESUMING = 2,
  PatrolBoatActionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  PatrolBoatActionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t PatrolBoatActionType_internal_data_[];
inline constexpr PatrolBoatActionType PatrolBoatActionType_MIN =
    static_cast<PatrolBoatActionType>(0);
inline constexpr PatrolBoatActionType PatrolBoatActionType_MAX =
    static_cast<PatrolBoatActionType>(2);
inline bool PatrolBoatActionType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int PatrolBoatActionType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PatrolBoatActionType_descriptor();
template <typename T>
::absl::string_view PatrolBoatActionType_Name(T value) {
  static_assert(::std::is_same<T, PatrolBoatActionType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PatrolBoatActionType_Name().");
  return PatrolBoatActionType_Name(static_cast<PatrolBoatActionType>(value));
}
template <>
inline ::absl::string_view PatrolBoatActionType_Name(PatrolBoatActionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PatrolBoatActionType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool PatrolBoatActionType_Parse(
    ::absl::string_view name, PatrolBoatActionType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<PatrolBoatActionType>(PatrolBoatActionType_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class SoundSignal final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:robocommand.roboboat.v1.SoundSignal) */ {
 public:
  inline SoundSignal() : SoundSignal(nullptr) {}
  ~SoundSignal() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SoundSignal* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SoundSignal));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SoundSignal(::google::protobuf::internal::ConstantInitialized);

  inline SoundSignal(const SoundSignal& from) : SoundSignal(nullptr, from) {}
  inline SoundSignal(SoundSignal&& from) noexcept
      : SoundSignal(nullptr, ::std::move(from)) {}
  inline SoundSignal& operator=(const SoundSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoundSignal& operator=(SoundSignal&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoundSignal& default_instance() {
    return *reinterpret_cast<const SoundSignal*>(
        &_SoundSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(SoundSignal& a, SoundSignal& b) { a.Swap(&b); }
  inline void Swap(SoundSignal* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoundSignal* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoundSignal* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SoundSignal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SoundSignal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SoundSignal& from) { SoundSignal::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SoundSignal* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "robocommand.roboboat.v1.SoundSignal"; }

 protected:
  explicit SoundSignal(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SoundSignal(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SoundSignal& from);
  SoundSignal(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SoundSignal&& from) noexcept
      : SoundSignal(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSignalTypeFieldNumber = 1,
    kFrequencyHzFieldNumber = 2,
    kAssignedTaskFieldNumber = 3,
  };
  // .robocommand.roboboat.v1.SignalType signal_type = 1;
  bool has_signal_type() const;
  void clear_signal_type() ;
  ::robocommand::roboboat::v1::SignalType signal_type() const;
  void set_signal_type(::robocommand::roboboat::v1::SignalType value);

  private:
  ::robocommand::roboboat::v1::SignalType _internal_signal_type() const;
  void _internal_set_signal_type(::robocommand::roboboat::v1::SignalType value);

  public:
  // uint32 frequency_hz = 2;
  bool has_frequency_hz() const;
  void clear_frequency_hz() ;
  ::uint32_t frequency_hz() const;
  void set_frequency_hz(::uint32_t value);

  private:
  ::uint32_t _internal_frequency_hz() const;
  void _internal_set_frequency_hz(::uint32_t value);

  public:
  // .robocommand.roboboat.v1.TaskType assigned_task = 3;
  bool has_assigned_task() const;
  void clear_assigned_task() ;
  ::robocommand::roboboat::v1::TaskType assigned_task() const;
  void set_assigned_task(::robocommand::roboboat::v1::TaskType value);

  private:
  ::robocommand::roboboat::v1::TaskType _internal_assigned_task() const;
  void _internal_set_assigned_task(::robocommand::roboboat::v1::TaskType value);

  public:
  // @@protoc_insertion_point(class_scope:robocommand.roboboat.v1.SoundSignal)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SoundSignal& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int signal_type_;
    ::uint32_t frequency_hz_;
    int assigned_task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2freport_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SoundSignal_class_data_;
// -------------------------------------------------------------------

class PatrolBoat final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:robocommand.roboboat.v1.PatrolBoat) */ {
 public:
  inline PatrolBoat() : PatrolBoat(nullptr) {}
  ~PatrolBoat() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PatrolBoat* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PatrolBoat));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PatrolBoat(::google::protobuf::internal::ConstantInitialized);

  inline PatrolBoat(const PatrolBoat& from) : PatrolBoat(nullptr, from) {}
  inline PatrolBoat(PatrolBoat&& from) noexcept
      : PatrolBoat(nullptr, ::std::move(from)) {}
  inline PatrolBoat& operator=(const PatrolBoat& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatrolBoat& operator=(PatrolBoat&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatrolBoat& default_instance() {
    return *reinterpret_cast<const PatrolBoat*>(
        &_PatrolBoat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(PatrolBoat& a, PatrolBoat& b) { a.Swap(&b); }
  inline void Swap(PatrolBoat* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatrolBoat* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatrolBoat* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PatrolBoat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatrolBoat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PatrolBoat& from) { PatrolBoat::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PatrolBoat* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "robocommand.roboboat.v1.PatrolBoat"; }

 protected:
  explicit PatrolBoat(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PatrolBoat(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PatrolBoat& from);
  PatrolBoat(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PatrolBoat&& from) noexcept
      : PatrolBoat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPatrolBoatActionTypeFieldNumber = 1,
  };
  // .robocommand.roboboat.v1.PatrolBoatActionType patrol_boat_action_type = 1;
  bool has_patrol_boat_action_type() const;
  void clear_patrol_boat_action_type() ;
  ::robocommand::roboboat::v1::PatrolBoatActionType patrol_boat_action_type() const;
  void set_patrol_boat_action_type(::robocommand::roboboat::v1::PatrolBoatActionType value);

  private:
  ::robocommand::roboboat::v1::PatrolBoatActionType _internal_patrol_boat_action_type() const;
  void _internal_set_patrol_boat_action_type(::robocommand::roboboat::v1::PatrolBoatActionType value);

  public:
  // @@protoc_insertion_point(class_scope:robocommand.roboboat.v1.PatrolBoat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PatrolBoat& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int patrol_boat_action_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2freport_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PatrolBoat_class_data_;
// -------------------------------------------------------------------

class LatLng final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:robocommand.roboboat.v1.LatLng) */ {
 public:
  inline LatLng() : LatLng(nullptr) {}
  ~LatLng() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LatLng* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LatLng));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LatLng(::google::protobuf::internal::ConstantInitialized);

  inline LatLng(const LatLng& from) : LatLng(nullptr, from) {}
  inline LatLng(LatLng&& from) noexcept
      : LatLng(nullptr, ::std::move(from)) {}
  inline LatLng& operator=(const LatLng& from) {
    CopyFrom(from);
    return *this;
  }
  inline LatLng& operator=(LatLng&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LatLng& default_instance() {
    return *reinterpret_cast<const LatLng*>(
        &_LatLng_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(LatLng& a, LatLng& b) { a.Swap(&b); }
  inline void Swap(LatLng* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LatLng* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LatLng* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LatLng>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LatLng& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LatLng& from) { LatLng::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LatLng* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "robocommand.roboboat.v1.LatLng"; }

 protected:
  explicit LatLng(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LatLng(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LatLng& from);
  LatLng(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LatLng&& from) noexcept
      : LatLng(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
  };
  // double latitude = 1;
  bool has_latitude() const;
  void clear_latitude() ;
  double latitude() const;
  void set_latitude(double value);

  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);

  public:
  // double longitude = 2;
  bool has_longitude() const;
  void clear_longitude() ;
  double longitude() const;
  void set_longitude(double value);

  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);

  public:
  // @@protoc_insertion_point(class_scope:robocommand.roboboat.v1.LatLng)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LatLng& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double latitude_;
    double longitude_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2freport_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LatLng_class_data_;
// -------------------------------------------------------------------

class Docking final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:robocommand.roboboat.v1.Docking) */ {
 public:
  inline Docking() : Docking(nullptr) {}
  ~Docking() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Docking* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Docking));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Docking(::google::protobuf::internal::ConstantInitialized);

  inline Docking(const Docking& from) : Docking(nullptr, from) {}
  inline Docking(Docking&& from) noexcept
      : Docking(nullptr, ::std::move(from)) {}
  inline Docking& operator=(const Docking& from) {
    CopyFrom(from);
    return *this;
  }
  inline Docking& operator=(Docking&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Docking& default_instance() {
    return *reinterpret_cast<const Docking*>(
        &_Docking_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Docking& a, Docking& b) { a.Swap(&b); }
  inline void Swap(Docking* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Docking* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Docking* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Docking>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Docking& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Docking& from) { Docking::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Docking* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "robocommand.roboboat.v1.Docking"; }

 protected:
  explicit Docking(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Docking(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Docking& from);
  Docking(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Docking&& from) noexcept
      : Docking(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDockFieldNumber = 1,
    kSlipFieldNumber = 2,
  };
  // string dock = 1;
  bool has_dock() const;
  void clear_dock() ;
  ::absl::string_view dock() const;
  template <typename Arg_ = ::std::string&&>
  void set_dock(Arg_&& arg);

  private:
  ::absl::string_view _internal_dock() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dock(::absl::string_view value);

  public:
  // string slip = 2;
  bool has_slip() const;
  void clear_slip() ;
  ::absl::string_view slip() const;
  template <typename Arg_ = ::std::string&&>
  void set_slip(Arg_&& arg);

  private:
  ::absl::string_view _internal_slip() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_slip(::absl::string_view value);

  public:
  // @@protoc_insertion_point(class_scope:robocommand.roboboat.v1.Docking)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 48,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Docking& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dock_;
    ::google::protobuf::internal::ArenaStringPtr slip_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2freport_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Docking_class_data_;
// -------------------------------------------------------------------

class ObjectDetected final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:robocommand.roboboat.v1.ObjectDetected) */ {
 public:
  inline ObjectDetected() : ObjectDetected(nullptr) {}
  ~ObjectDetected() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ObjectDetected* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ObjectDetected));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectDetected(::google::protobuf::internal::ConstantInitialized);

  inline ObjectDetected(const ObjectDetected& from) : ObjectDetected(nullptr, from) {}
  inline ObjectDetected(ObjectDetected&& from) noexcept
      : ObjectDetected(nullptr, ::std::move(from)) {}
  inline ObjectDetected& operator=(const ObjectDetected& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDetected& operator=(ObjectDetected&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectDetected& default_instance() {
    return *reinterpret_cast<const ObjectDetected*>(
        &_ObjectDetected_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ObjectDetected& a, ObjectDetected& b) { a.Swap(&b); }
  inline void Swap(ObjectDetected* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDetected* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectDetected* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ObjectDetected>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectDetected& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectDetected& from) { ObjectDetected::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ObjectDetected* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "robocommand.roboboat.v1.ObjectDetected"; }

 protected:
  explicit ObjectDetected(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ObjectDetected(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ObjectDetected& from);
  ObjectDetected(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ObjectDetected&& from) noexcept
      : ObjectDetected(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 3,
    kObjectTypeFieldNumber = 1,
    kColorFieldNumber = 2,
    kObjectIdFieldNumber = 4,
    kTaskContextFieldNumber = 5,
  };
  // .robocommand.roboboat.v1.LatLng position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::robocommand::roboboat::v1::LatLng& position() const;
  [[nodiscard]] ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE release_position();
  ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value);
  ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::robocommand::roboboat::v1::LatLng& _internal_position() const;
  ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // .robocommand.roboboat.v1.ObjectType object_type = 1;
  bool has_object_type() const;
  void clear_object_type() ;
  ::robocommand::roboboat::v1::ObjectType object_type() const;
  void set_object_type(::robocommand::roboboat::v1::ObjectType value);

  private:
  ::robocommand::roboboat::v1::ObjectType _internal_object_type() const;
  void _internal_set_object_type(::robocommand::roboboat::v1::ObjectType value);

  public:
  // .robocommand.roboboat.v1.Color color = 2;
  bool has_color() const;
  void clear_color() ;
  ::robocommand::roboboat::v1::Color color() const;
  void set_color(::robocommand::roboboat::v1::Color value);

  private:
  ::robocommand::roboboat::v1::Color _internal_color() const;
  void _internal_set_color(::robocommand::roboboat::v1::Color value);

  public:
  // uint32 object_id = 4;
  bool has_object_id() const;
  void clear_object_id() ;
  ::uint32_t object_id() const;
  void set_object_id(::uint32_t value);

  private:
  ::uint32_t _internal_object_id() const;
  void _internal_set_object_id(::uint32_t value);

  public:
  // .robocommand.roboboat.v1.TaskType task_context = 5;
  bool has_task_context() const;
  void clear_task_context() ;
  ::robocommand::roboboat::v1::TaskType task_context() const;
  void set_task_context(::robocommand::roboboat::v1::TaskType value);

  private:
  ::robocommand::roboboat::v1::TaskType _internal_task_context() const;
  void _internal_set_task_context(::robocommand::roboboat::v1::TaskType value);

  public:
  // @@protoc_insertion_point(class_scope:robocommand.roboboat.v1.ObjectDetected)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ObjectDetected& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE position_;
    int object_type_;
    int color_;
    ::uint32_t object_id_;
    int task_context_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2freport_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ObjectDetected_class_data_;
// -------------------------------------------------------------------

class ObjectDelivery final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:robocommand.roboboat.v1.ObjectDelivery) */ {
 public:
  inline ObjectDelivery() : ObjectDelivery(nullptr) {}
  ~ObjectDelivery() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ObjectDelivery* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ObjectDelivery));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObjectDelivery(::google::protobuf::internal::ConstantInitialized);

  inline ObjectDelivery(const ObjectDelivery& from) : ObjectDelivery(nullptr, from) {}
  inline ObjectDelivery(ObjectDelivery&& from) noexcept
      : ObjectDelivery(nullptr, ::std::move(from)) {}
  inline ObjectDelivery& operator=(const ObjectDelivery& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDelivery& operator=(ObjectDelivery&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectDelivery& default_instance() {
    return *reinterpret_cast<const ObjectDelivery*>(
        &_ObjectDelivery_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ObjectDelivery& a, ObjectDelivery& b) { a.Swap(&b); }
  inline void Swap(ObjectDelivery* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDelivery* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectDelivery* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ObjectDelivery>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObjectDelivery& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObjectDelivery& from) { ObjectDelivery::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ObjectDelivery* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "robocommand.roboboat.v1.ObjectDelivery"; }

 protected:
  explicit ObjectDelivery(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ObjectDelivery(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ObjectDelivery& from);
  ObjectDelivery(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ObjectDelivery&& from) noexcept
      : ObjectDelivery(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 2,
    kVesselColorFieldNumber = 1,
    kDeliveryTypeFieldNumber = 3,
  };
  // .robocommand.roboboat.v1.LatLng position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::robocommand::roboboat::v1::LatLng& position() const;
  [[nodiscard]] ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE release_position();
  ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value);
  ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::robocommand::roboboat::v1::LatLng& _internal_position() const;
  ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // .robocommand.roboboat.v1.Color vessel_color = 1;
  bool has_vessel_color() const;
  void clear_vessel_color() ;
  ::robocommand::roboboat::v1::Color vessel_color() const;
  void set_vessel_color(::robocommand::roboboat::v1::Color value);

  private:
  ::robocommand::roboboat::v1::Color _internal_vessel_color() const;
  void _internal_set_vessel_color(::robocommand::roboboat::v1::Color value);

  public:
  // .robocommand.roboboat.v1.DeliveryType delivery_type = 3;
  bool has_delivery_type() const;
  void clear_delivery_type() ;
  ::robocommand::roboboat::v1::DeliveryType delivery_type() const;
  void set_delivery_type(::robocommand::roboboat::v1::DeliveryType value);

  private:
  ::robocommand::roboboat::v1::DeliveryType _internal_delivery_type() const;
  void _internal_set_delivery_type(::robocommand::roboboat::v1::DeliveryType value);

  public:
  // @@protoc_insertion_point(class_scope:robocommand.roboboat.v1.ObjectDelivery)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ObjectDelivery& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE position_;
    int vessel_color_;
    int delivery_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2freport_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ObjectDelivery_class_data_;
// -------------------------------------------------------------------

class Heartbeat final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:robocommand.roboboat.v1.Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {}
  ~Heartbeat() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Heartbeat* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Heartbeat));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Heartbeat(::google::protobuf::internal::ConstantInitialized);

  inline Heartbeat(const Heartbeat& from) : Heartbeat(nullptr, from) {}
  inline Heartbeat(Heartbeat&& from) noexcept
      : Heartbeat(nullptr, ::std::move(from)) {}
  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Heartbeat& default_instance() {
    return *reinterpret_cast<const Heartbeat*>(
        &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Heartbeat& a, Heartbeat& b) { a.Swap(&b); }
  inline void Swap(Heartbeat* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Heartbeat* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Heartbeat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Heartbeat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Heartbeat& from) { Heartbeat::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Heartbeat* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "robocommand.roboboat.v1.Heartbeat"; }

 protected:
  explicit Heartbeat(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Heartbeat(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Heartbeat& from);
  Heartbeat(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Heartbeat&& from) noexcept
      : Heartbeat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 2,
    kStateFieldNumber = 1,
    kSpdMpsFieldNumber = 3,
    kHeadingDegFieldNumber = 4,
    kCurrentTaskFieldNumber = 5,
  };
  // .robocommand.roboboat.v1.LatLng position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::robocommand::roboboat::v1::LatLng& position() const;
  [[nodiscard]] ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE release_position();
  ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value);
  ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::robocommand::roboboat::v1::LatLng& _internal_position() const;
  ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // .robocommand.roboboat.v1.RobotState state = 1;
  bool has_state() const;
  void clear_state() ;
  ::robocommand::roboboat::v1::RobotState state() const;
  void set_state(::robocommand::roboboat::v1::RobotState value);

  private:
  ::robocommand::roboboat::v1::RobotState _internal_state() const;
  void _internal_set_state(::robocommand::roboboat::v1::RobotState value);

  public:
  // float spd_mps = 3;
  bool has_spd_mps() const;
  void clear_spd_mps() ;
  float spd_mps() const;
  void set_spd_mps(float value);

  private:
  float _internal_spd_mps() const;
  void _internal_set_spd_mps(float value);

  public:
  // float heading_deg = 4;
  bool has_heading_deg() const;
  void clear_heading_deg() ;
  float heading_deg() const;
  void set_heading_deg(float value);

  private:
  float _internal_heading_deg() const;
  void _internal_set_heading_deg(float value);

  public:
  // .robocommand.roboboat.v1.TaskType current_task = 5;
  bool has_current_task() const;
  void clear_current_task() ;
  ::robocommand::roboboat::v1::TaskType current_task() const;
  void set_current_task(::robocommand::roboboat::v1::TaskType value);

  private:
  ::robocommand::roboboat::v1::TaskType _internal_current_task() const;
  void _internal_set_current_task(::robocommand::roboboat::v1::TaskType value);

  public:
  // @@protoc_insertion_point(class_scope:robocommand.roboboat.v1.Heartbeat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Heartbeat& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE position_;
    int state_;
    float spd_mps_;
    float heading_deg_;
    int current_task_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2freport_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Heartbeat_class_data_;
// -------------------------------------------------------------------

class GatePass final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:robocommand.roboboat.v1.GatePass) */ {
 public:
  inline GatePass() : GatePass(nullptr) {}
  ~GatePass() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GatePass* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GatePass));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GatePass(::google::protobuf::internal::ConstantInitialized);

  inline GatePass(const GatePass& from) : GatePass(nullptr, from) {}
  inline GatePass(GatePass&& from) noexcept
      : GatePass(nullptr, ::std::move(from)) {}
  inline GatePass& operator=(const GatePass& from) {
    CopyFrom(from);
    return *this;
  }
  inline GatePass& operator=(GatePass&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GatePass& default_instance() {
    return *reinterpret_cast<const GatePass*>(
        &_GatePass_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(GatePass& a, GatePass& b) { a.Swap(&b); }
  inline void Swap(GatePass* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GatePass* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GatePass* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GatePass>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GatePass& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GatePass& from) { GatePass::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GatePass* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "robocommand.roboboat.v1.GatePass"; }

 protected:
  explicit GatePass(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GatePass(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GatePass& from);
  GatePass(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GatePass&& from) noexcept
      : GatePass(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .robocommand.roboboat.v1.LatLng position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::robocommand::roboboat::v1::LatLng& position() const;
  [[nodiscard]] ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE release_position();
  ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value);
  ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::robocommand::roboboat::v1::LatLng& _internal_position() const;
  ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // .robocommand.roboboat.v1.GateType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::robocommand::roboboat::v1::GateType type() const;
  void set_type(::robocommand::roboboat::v1::GateType value);

  private:
  ::robocommand::roboboat::v1::GateType _internal_type() const;
  void _internal_set_type(::robocommand::roboboat::v1::GateType value);

  public:
  // @@protoc_insertion_point(class_scope:robocommand.roboboat.v1.GatePass)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GatePass& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE position_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2freport_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GatePass_class_data_;
// -------------------------------------------------------------------

class Report final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:robocommand.roboboat.v1.Report) */ {
 public:
  inline Report() : Report(nullptr) {}
  ~Report() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Report* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Report));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Report(::google::protobuf::internal::ConstantInitialized);

  inline Report(const Report& from) : Report(nullptr, from) {}
  inline Report(Report&& from) noexcept
      : Report(nullptr, ::std::move(from)) {}
  inline Report& operator=(const Report& from) {
    CopyFrom(from);
    return *this;
  }
  inline Report& operator=(Report&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Report& default_instance() {
    return *reinterpret_cast<const Report*>(
        &_Report_default_instance_);
  }
  enum BodyCase {
    kHeartbeat = 10,
    kObjectDetected = 11,
    kGatePass = 12,
    kObjectDelivery = 13,
    kDocking = 14,
    kSoundSignal = 15,
    kPatrolBoat = 16,
    BODY_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Report& a, Report& b) { a.Swap(&b); }
  inline void Swap(Report* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Report* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Report* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Report>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Report& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Report& from) { Report::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Report* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "robocommand.roboboat.v1.Report"; }

 protected:
  explicit Report(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Report(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Report& from);
  Report(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Report&& from) noexcept
      : Report(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTeamIdFieldNumber = 1,
    kVehicleIdFieldNumber = 2,
    kSentAtFieldNumber = 4,
    kSeqFieldNumber = 3,
    kHeartbeatFieldNumber = 10,
    kObjectDetectedFieldNumber = 11,
    kGatePassFieldNumber = 12,
    kObjectDeliveryFieldNumber = 13,
    kDockingFieldNumber = 14,
    kSoundSignalFieldNumber = 15,
    kPatrolBoatFieldNumber = 16,
  };
  // string team_id = 1;
  bool has_team_id() const;
  void clear_team_id() ;
  ::absl::string_view team_id() const;
  template <typename Arg_ = ::std::string&&>
  void set_team_id(Arg_&& arg);

  private:
  ::absl::string_view _internal_team_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_team_id(::absl::string_view value);

  public:
  // string vehicle_id = 2;
  bool has_vehicle_id() const;
  void clear_vehicle_id() ;
  ::absl::string_view vehicle_id() const;
  template <typename Arg_ = ::std::string&&>
  void set_vehicle_id(Arg_&& arg);

  private:
  ::absl::string_view _internal_vehicle_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_vehicle_id(::absl::string_view value);

  public:
  // .google.protobuf.Timestamp sent_at = 4;
  bool has_sent_at() const;
  void clear_sent_at() ;
  const ::google::protobuf::Timestamp& sent_at() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_sent_at();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_sent_at();
  void set_allocated_sent_at(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sent_at(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_sent_at();

  private:
  const ::google::protobuf::Timestamp& _internal_sent_at() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_sent_at();

  public:
  // uint32 seq = 3;
  bool has_seq() const;
  void clear_seq() ;
  ::uint32_t seq() const;
  void set_seq(::uint32_t value);

  private:
  ::uint32_t _internal_seq() const;
  void _internal_set_seq(::uint32_t value);

  public:
  // .robocommand.roboboat.v1.Heartbeat heartbeat = 10;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;

  public:
  void clear_heartbeat() ;
  const ::robocommand::roboboat::v1::Heartbeat& heartbeat() const;
  [[nodiscard]] ::robocommand::roboboat::v1::Heartbeat* PROTOBUF_NULLABLE release_heartbeat();
  ::robocommand::roboboat::v1::Heartbeat* PROTOBUF_NONNULL mutable_heartbeat();
  void set_allocated_heartbeat(::robocommand::roboboat::v1::Heartbeat* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_heartbeat(::robocommand::roboboat::v1::Heartbeat* PROTOBUF_NULLABLE value);
  ::robocommand::roboboat::v1::Heartbeat* PROTOBUF_NULLABLE unsafe_arena_release_heartbeat();

  private:
  const ::robocommand::roboboat::v1::Heartbeat& _internal_heartbeat() const;
  ::robocommand::roboboat::v1::Heartbeat* PROTOBUF_NONNULL _internal_mutable_heartbeat();

  public:
  // .robocommand.roboboat.v1.ObjectDetected object_detected = 11;
  bool has_object_detected() const;
  private:
  bool _internal_has_object_detected() const;

  public:
  void clear_object_detected() ;
  const ::robocommand::roboboat::v1::ObjectDetected& object_detected() const;
  [[nodiscard]] ::robocommand::roboboat::v1::ObjectDetected* PROTOBUF_NULLABLE release_object_detected();
  ::robocommand::roboboat::v1::ObjectDetected* PROTOBUF_NONNULL mutable_object_detected();
  void set_allocated_object_detected(::robocommand::roboboat::v1::ObjectDetected* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_object_detected(::robocommand::roboboat::v1::ObjectDetected* PROTOBUF_NULLABLE value);
  ::robocommand::roboboat::v1::ObjectDetected* PROTOBUF_NULLABLE unsafe_arena_release_object_detected();

  private:
  const ::robocommand::roboboat::v1::ObjectDetected& _internal_object_detected() const;
  ::robocommand::roboboat::v1::ObjectDetected* PROTOBUF_NONNULL _internal_mutable_object_detected();

  public:
  // .robocommand.roboboat.v1.GatePass gate_pass = 12;
  bool has_gate_pass() const;
  private:
  bool _internal_has_gate_pass() const;

  public:
  void clear_gate_pass() ;
  const ::robocommand::roboboat::v1::GatePass& gate_pass() const;
  [[nodiscard]] ::robocommand::roboboat::v1::GatePass* PROTOBUF_NULLABLE release_gate_pass();
  ::robocommand::roboboat::v1::GatePass* PROTOBUF_NONNULL mutable_gate_pass();
  void set_allocated_gate_pass(::robocommand::roboboat::v1::GatePass* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_gate_pass(::robocommand::roboboat::v1::GatePass* PROTOBUF_NULLABLE value);
  ::robocommand::roboboat::v1::GatePass* PROTOBUF_NULLABLE unsafe_arena_release_gate_pass();

  private:
  const ::robocommand::roboboat::v1::GatePass& _internal_gate_pass() const;
  ::robocommand::roboboat::v1::GatePass* PROTOBUF_NONNULL _internal_mutable_gate_pass();

  public:
  // .robocommand.roboboat.v1.ObjectDelivery object_delivery = 13;
  bool has_object_delivery() const;
  private:
  bool _internal_has_object_delivery() const;

  public:
  void clear_object_delivery() ;
  const ::robocommand::roboboat::v1::ObjectDelivery& object_delivery() const;
  [[nodiscard]] ::robocommand::roboboat::v1::ObjectDelivery* PROTOBUF_NULLABLE release_object_delivery();
  ::robocommand::roboboat::v1::ObjectDelivery* PROTOBUF_NONNULL mutable_object_delivery();
  void set_allocated_object_delivery(::robocommand::roboboat::v1::ObjectDelivery* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_object_delivery(::robocommand::roboboat::v1::ObjectDelivery* PROTOBUF_NULLABLE value);
  ::robocommand::roboboat::v1::ObjectDelivery* PROTOBUF_NULLABLE unsafe_arena_release_object_delivery();

  private:
  const ::robocommand::roboboat::v1::ObjectDelivery& _internal_object_delivery() const;
  ::robocommand::roboboat::v1::ObjectDelivery* PROTOBUF_NONNULL _internal_mutable_object_delivery();

  public:
  // .robocommand.roboboat.v1.Docking docking = 14;
  bool has_docking() const;
  private:
  bool _internal_has_docking() const;

  public:
  void clear_docking() ;
  const ::robocommand::roboboat::v1::Docking& docking() const;
  [[nodiscard]] ::robocommand::roboboat::v1::Docking* PROTOBUF_NULLABLE release_docking();
  ::robocommand::roboboat::v1::Docking* PROTOBUF_NONNULL mutable_docking();
  void set_allocated_docking(::robocommand::roboboat::v1::Docking* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_docking(::robocommand::roboboat::v1::Docking* PROTOBUF_NULLABLE value);
  ::robocommand::roboboat::v1::Docking* PROTOBUF_NULLABLE unsafe_arena_release_docking();

  private:
  const ::robocommand::roboboat::v1::Docking& _internal_docking() const;
  ::robocommand::roboboat::v1::Docking* PROTOBUF_NONNULL _internal_mutable_docking();

  public:
  // .robocommand.roboboat.v1.SoundSignal sound_signal = 15;
  bool has_sound_signal() const;
  private:
  bool _internal_has_sound_signal() const;

  public:
  void clear_sound_signal() ;
  const ::robocommand::roboboat::v1::SoundSignal& sound_signal() const;
  [[nodiscard]] ::robocommand::roboboat::v1::SoundSignal* PROTOBUF_NULLABLE release_sound_signal();
  ::robocommand::roboboat::v1::SoundSignal* PROTOBUF_NONNULL mutable_sound_signal();
  void set_allocated_sound_signal(::robocommand::roboboat::v1::SoundSignal* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sound_signal(::robocommand::roboboat::v1::SoundSignal* PROTOBUF_NULLABLE value);
  ::robocommand::roboboat::v1::SoundSignal* PROTOBUF_NULLABLE unsafe_arena_release_sound_signal();

  private:
  const ::robocommand::roboboat::v1::SoundSignal& _internal_sound_signal() const;
  ::robocommand::roboboat::v1::SoundSignal* PROTOBUF_NONNULL _internal_mutable_sound_signal();

  public:
  // .robocommand.roboboat.v1.PatrolBoat patrol_boat = 16;
  bool has_patrol_boat() const;
  private:
  bool _internal_has_patrol_boat() const;

  public:
  void clear_patrol_boat() ;
  const ::robocommand::roboboat::v1::PatrolBoat& patrol_boat() const;
  [[nodiscard]] ::robocommand::roboboat::v1::PatrolBoat* PROTOBUF_NULLABLE release_patrol_boat();
  ::robocommand::roboboat::v1::PatrolBoat* PROTOBUF_NONNULL mutable_patrol_boat();
  void set_allocated_patrol_boat(::robocommand::roboboat::v1::PatrolBoat* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_patrol_boat(::robocommand::roboboat::v1::PatrolBoat* PROTOBUF_NULLABLE value);
  ::robocommand::roboboat::v1::PatrolBoat* PROTOBUF_NULLABLE unsafe_arena_release_patrol_boat();

  private:
  const ::robocommand::roboboat::v1::PatrolBoat& _internal_patrol_boat() const;
  ::robocommand::roboboat::v1::PatrolBoat* PROTOBUF_NONNULL _internal_mutable_patrol_boat();

  public:
  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:robocommand.roboboat.v1.Report)
 private:
  class _Internal;
  void set_has_heartbeat();
  void set_has_object_detected();
  void set_has_gate_pass();
  void set_has_object_delivery();
  void set_has_docking();
  void set_has_sound_signal();
  void set_has_patrol_boat();
  inline bool has_body() const;
  inline void clear_has_body();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 11,
                                   8, 64,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Report& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr team_id_;
    ::google::protobuf::internal::ArenaStringPtr vehicle_id_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE sent_at_;
    ::uint32_t seq_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE heartbeat_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE object_detected_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE gate_pass_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE object_delivery_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE docking_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sound_signal_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE patrol_boat_;
    } body_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2freport_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Report_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Report

// string team_id = 1;
inline bool Report::has_team_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  return value;
}
inline void Report::clear_team_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.team_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::absl::string_view Report::team_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Report.team_id)
  return _internal_team_id();
}
template <typename Arg_>
PROTOBUF_ALWAYS_INLINE void Report::set_team_id(Arg_&& arg) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.team_id_.Set(static_cast<Arg_&&>(arg), GetArena());
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.Report.team_id)
}
inline ::absl::string_view Report::_internal_team_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.team_id_.Get();
}
inline void Report::_internal_set_team_id(::absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.team_id_.Set(value, GetArena());
}

// string vehicle_id = 2;
inline bool Report::has_vehicle_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  return value;
}
inline void Report::clear_vehicle_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vehicle_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::absl::string_view Report::vehicle_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Report.vehicle_id)
  return _internal_vehicle_id();
}
template <typename Arg_>
PROTOBUF_ALWAYS_INLINE void Report::set_vehicle_id(Arg_&& arg) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.vehicle_id_.Set(static_cast<Arg_&&>(arg), GetArena());
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.Report.vehicle_id)
}
inline ::absl::string_view Report::_internal_vehicle_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vehicle_id_.Get();
}
inline void Report::_internal_set_vehicle_id(::absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.vehicle_id_.Set(value, GetArena());
}

// uint32 seq = 3;
inline bool Report::has_seq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008U) != 0;
  return value;
}
inline void Report::clear_seq() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seq_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline ::uint32_t Report::seq() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Report.seq)
  return _internal_seq();
}
inline void Report::set_seq(::uint32_t value) {
  _internal_set_seq(value);
  _impl_._has_bits_[0] |= 0x00000008U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.Report.seq)
}
inline ::uint32_t Report::_internal_seq() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.seq_;
}
inline void Report::_internal_set_seq(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seq_ = value;
}

// .google.protobuf.Timestamp sent_at = 4;
inline bool Report::has_sent_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sent_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Report::_internal_sent_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.sent_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Report::sent_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Report.sent_at)
  return _internal_sent_at();
}
inline void Report::unsafe_arena_set_allocated_sent_at(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sent_at_);
  }
  _impl_.sent_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robocommand.roboboat.v1.Report.sent_at)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE Report::release_sent_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004U;
  ::google::protobuf::Timestamp* released = _impl_.sent_at_;
  _impl_.sent_at_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE Report::unsafe_arena_release_sent_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:robocommand.roboboat.v1.Report.sent_at)

  _impl_._has_bits_[0] &= ~0x00000004U;
  ::google::protobuf::Timestamp* temp = _impl_.sent_at_;
  _impl_.sent_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL Report::_internal_mutable_sent_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sent_at_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.sent_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.sent_at_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL Report::mutable_sent_at()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004U;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_sent_at();
  // @@protoc_insertion_point(field_mutable:robocommand.roboboat.v1.Report.sent_at)
  return _msg;
}
inline void Report::set_allocated_sent_at(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sent_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }

  _impl_.sent_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:robocommand.roboboat.v1.Report.sent_at)
}

// .robocommand.roboboat.v1.Heartbeat heartbeat = 10;
inline bool Report::has_heartbeat() const {
  return body_case() == kHeartbeat;
}
inline bool Report::_internal_has_heartbeat() const {
  return body_case() == kHeartbeat;
}
inline void Report::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void Report::clear_heartbeat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kHeartbeat) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.heartbeat_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.heartbeat_);
    }
    clear_has_body();
  }
}
inline ::robocommand::roboboat::v1::Heartbeat* PROTOBUF_NULLABLE Report::release_heartbeat() {
  // @@protoc_insertion_point(field_release:robocommand.roboboat.v1.Report.heartbeat)
  if (body_case() == kHeartbeat) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::Heartbeat*>(_impl_.body_.heartbeat_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robocommand::roboboat::v1::Heartbeat& Report::_internal_heartbeat() const {
  return body_case() == kHeartbeat ? *reinterpret_cast<::robocommand::roboboat::v1::Heartbeat*>(_impl_.body_.heartbeat_) : reinterpret_cast<::robocommand::roboboat::v1::Heartbeat&>(::robocommand::roboboat::v1::_Heartbeat_default_instance_);
}
inline const ::robocommand::roboboat::v1::Heartbeat& Report::heartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Report.heartbeat)
  return _internal_heartbeat();
}
inline ::robocommand::roboboat::v1::Heartbeat* PROTOBUF_NULLABLE Report::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robocommand.roboboat.v1.Report.heartbeat)
  if (body_case() == kHeartbeat) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::Heartbeat*>(_impl_.body_.heartbeat_);
    _impl_.body_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Report::unsafe_arena_set_allocated_heartbeat(
    ::robocommand::roboboat::v1::Heartbeat* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_heartbeat();
    _impl_.body_.heartbeat_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robocommand.roboboat.v1.Report.heartbeat)
}
inline ::robocommand::roboboat::v1::Heartbeat* PROTOBUF_NONNULL Report::_internal_mutable_heartbeat() {
  if (body_case() != kHeartbeat) {
    clear_body();
    set_has_heartbeat();
    _impl_.body_.heartbeat_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::robocommand::roboboat::v1::Heartbeat>(GetArena()));
  }
  return reinterpret_cast<::robocommand::roboboat::v1::Heartbeat*>(_impl_.body_.heartbeat_);
}
inline ::robocommand::roboboat::v1::Heartbeat* PROTOBUF_NONNULL Report::mutable_heartbeat()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::robocommand::roboboat::v1::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:robocommand.roboboat.v1.Report.heartbeat)
  return _msg;
}

// .robocommand.roboboat.v1.ObjectDetected object_detected = 11;
inline bool Report::has_object_detected() const {
  return body_case() == kObjectDetected;
}
inline bool Report::_internal_has_object_detected() const {
  return body_case() == kObjectDetected;
}
inline void Report::set_has_object_detected() {
  _impl_._oneof_case_[0] = kObjectDetected;
}
inline void Report::clear_object_detected() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kObjectDetected) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.object_detected_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.object_detected_);
    }
    clear_has_body();
  }
}
inline ::robocommand::roboboat::v1::ObjectDetected* PROTOBUF_NULLABLE Report::release_object_detected() {
  // @@protoc_insertion_point(field_release:robocommand.roboboat.v1.Report.object_detected)
  if (body_case() == kObjectDetected) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::ObjectDetected*>(_impl_.body_.object_detected_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.object_detected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robocommand::roboboat::v1::ObjectDetected& Report::_internal_object_detected() const {
  return body_case() == kObjectDetected ? *reinterpret_cast<::robocommand::roboboat::v1::ObjectDetected*>(_impl_.body_.object_detected_) : reinterpret_cast<::robocommand::roboboat::v1::ObjectDetected&>(::robocommand::roboboat::v1::_ObjectDetected_default_instance_);
}
inline const ::robocommand::roboboat::v1::ObjectDetected& Report::object_detected() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Report.object_detected)
  return _internal_object_detected();
}
inline ::robocommand::roboboat::v1::ObjectDetected* PROTOBUF_NULLABLE Report::unsafe_arena_release_object_detected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robocommand.roboboat.v1.Report.object_detected)
  if (body_case() == kObjectDetected) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::ObjectDetected*>(_impl_.body_.object_detected_);
    _impl_.body_.object_detected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Report::unsafe_arena_set_allocated_object_detected(
    ::robocommand::roboboat::v1::ObjectDetected* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_object_detected();
    _impl_.body_.object_detected_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robocommand.roboboat.v1.Report.object_detected)
}
inline ::robocommand::roboboat::v1::ObjectDetected* PROTOBUF_NONNULL Report::_internal_mutable_object_detected() {
  if (body_case() != kObjectDetected) {
    clear_body();
    set_has_object_detected();
    _impl_.body_.object_detected_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::robocommand::roboboat::v1::ObjectDetected>(GetArena()));
  }
  return reinterpret_cast<::robocommand::roboboat::v1::ObjectDetected*>(_impl_.body_.object_detected_);
}
inline ::robocommand::roboboat::v1::ObjectDetected* PROTOBUF_NONNULL Report::mutable_object_detected()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::robocommand::roboboat::v1::ObjectDetected* _msg = _internal_mutable_object_detected();
  // @@protoc_insertion_point(field_mutable:robocommand.roboboat.v1.Report.object_detected)
  return _msg;
}

// .robocommand.roboboat.v1.GatePass gate_pass = 12;
inline bool Report::has_gate_pass() const {
  return body_case() == kGatePass;
}
inline bool Report::_internal_has_gate_pass() const {
  return body_case() == kGatePass;
}
inline void Report::set_has_gate_pass() {
  _impl_._oneof_case_[0] = kGatePass;
}
inline void Report::clear_gate_pass() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kGatePass) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.gate_pass_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.gate_pass_);
    }
    clear_has_body();
  }
}
inline ::robocommand::roboboat::v1::GatePass* PROTOBUF_NULLABLE Report::release_gate_pass() {
  // @@protoc_insertion_point(field_release:robocommand.roboboat.v1.Report.gate_pass)
  if (body_case() == kGatePass) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::GatePass*>(_impl_.body_.gate_pass_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.gate_pass_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robocommand::roboboat::v1::GatePass& Report::_internal_gate_pass() const {
  return body_case() == kGatePass ? *reinterpret_cast<::robocommand::roboboat::v1::GatePass*>(_impl_.body_.gate_pass_) : reinterpret_cast<::robocommand::roboboat::v1::GatePass&>(::robocommand::roboboat::v1::_GatePass_default_instance_);
}
inline const ::robocommand::roboboat::v1::GatePass& Report::gate_pass() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Report.gate_pass)
  return _internal_gate_pass();
}
inline ::robocommand::roboboat::v1::GatePass* PROTOBUF_NULLABLE Report::unsafe_arena_release_gate_pass() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robocommand.roboboat.v1.Report.gate_pass)
  if (body_case() == kGatePass) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::GatePass*>(_impl_.body_.gate_pass_);
    _impl_.body_.gate_pass_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Report::unsafe_arena_set_allocated_gate_pass(
    ::robocommand::roboboat::v1::GatePass* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_gate_pass();
    _impl_.body_.gate_pass_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robocommand.roboboat.v1.Report.gate_pass)
}
inline ::robocommand::roboboat::v1::GatePass* PROTOBUF_NONNULL Report::_internal_mutable_gate_pass() {
  if (body_case() != kGatePass) {
    clear_body();
    set_has_gate_pass();
    _impl_.body_.gate_pass_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::robocommand::roboboat::v1::GatePass>(GetArena()));
  }
  return reinterpret_cast<::robocommand::roboboat::v1::GatePass*>(_impl_.body_.gate_pass_);
}
inline ::robocommand::roboboat::v1::GatePass* PROTOBUF_NONNULL Report::mutable_gate_pass()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::robocommand::roboboat::v1::GatePass* _msg = _internal_mutable_gate_pass();
  // @@protoc_insertion_point(field_mutable:robocommand.roboboat.v1.Report.gate_pass)
  return _msg;
}

// .robocommand.roboboat.v1.ObjectDelivery object_delivery = 13;
inline bool Report::has_object_delivery() const {
  return body_case() == kObjectDelivery;
}
inline bool Report::_internal_has_object_delivery() const {
  return body_case() == kObjectDelivery;
}
inline void Report::set_has_object_delivery() {
  _impl_._oneof_case_[0] = kObjectDelivery;
}
inline void Report::clear_object_delivery() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kObjectDelivery) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.object_delivery_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.object_delivery_);
    }
    clear_has_body();
  }
}
inline ::robocommand::roboboat::v1::ObjectDelivery* PROTOBUF_NULLABLE Report::release_object_delivery() {
  // @@protoc_insertion_point(field_release:robocommand.roboboat.v1.Report.object_delivery)
  if (body_case() == kObjectDelivery) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::ObjectDelivery*>(_impl_.body_.object_delivery_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.object_delivery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robocommand::roboboat::v1::ObjectDelivery& Report::_internal_object_delivery() const {
  return body_case() == kObjectDelivery ? *reinterpret_cast<::robocommand::roboboat::v1::ObjectDelivery*>(_impl_.body_.object_delivery_) : reinterpret_cast<::robocommand::roboboat::v1::ObjectDelivery&>(::robocommand::roboboat::v1::_ObjectDelivery_default_instance_);
}
inline const ::robocommand::roboboat::v1::ObjectDelivery& Report::object_delivery() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Report.object_delivery)
  return _internal_object_delivery();
}
inline ::robocommand::roboboat::v1::ObjectDelivery* PROTOBUF_NULLABLE Report::unsafe_arena_release_object_delivery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robocommand.roboboat.v1.Report.object_delivery)
  if (body_case() == kObjectDelivery) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::ObjectDelivery*>(_impl_.body_.object_delivery_);
    _impl_.body_.object_delivery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Report::unsafe_arena_set_allocated_object_delivery(
    ::robocommand::roboboat::v1::ObjectDelivery* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_object_delivery();
    _impl_.body_.object_delivery_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robocommand.roboboat.v1.Report.object_delivery)
}
inline ::robocommand::roboboat::v1::ObjectDelivery* PROTOBUF_NONNULL Report::_internal_mutable_object_delivery() {
  if (body_case() != kObjectDelivery) {
    clear_body();
    set_has_object_delivery();
    _impl_.body_.object_delivery_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::robocommand::roboboat::v1::ObjectDelivery>(GetArena()));
  }
  return reinterpret_cast<::robocommand::roboboat::v1::ObjectDelivery*>(_impl_.body_.object_delivery_);
}
inline ::robocommand::roboboat::v1::ObjectDelivery* PROTOBUF_NONNULL Report::mutable_object_delivery()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::robocommand::roboboat::v1::ObjectDelivery* _msg = _internal_mutable_object_delivery();
  // @@protoc_insertion_point(field_mutable:robocommand.roboboat.v1.Report.object_delivery)
  return _msg;
}

// .robocommand.roboboat.v1.Docking docking = 14;
inline bool Report::has_docking() const {
  return body_case() == kDocking;
}
inline bool Report::_internal_has_docking() const {
  return body_case() == kDocking;
}
inline void Report::set_has_docking() {
  _impl_._oneof_case_[0] = kDocking;
}
inline void Report::clear_docking() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kDocking) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.docking_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.docking_);
    }
    clear_has_body();
  }
}
inline ::robocommand::roboboat::v1::Docking* PROTOBUF_NULLABLE Report::release_docking() {
  // @@protoc_insertion_point(field_release:robocommand.roboboat.v1.Report.docking)
  if (body_case() == kDocking) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::Docking*>(_impl_.body_.docking_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.docking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robocommand::roboboat::v1::Docking& Report::_internal_docking() const {
  return body_case() == kDocking ? *reinterpret_cast<::robocommand::roboboat::v1::Docking*>(_impl_.body_.docking_) : reinterpret_cast<::robocommand::roboboat::v1::Docking&>(::robocommand::roboboat::v1::_Docking_default_instance_);
}
inline const ::robocommand::roboboat::v1::Docking& Report::docking() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Report.docking)
  return _internal_docking();
}
inline ::robocommand::roboboat::v1::Docking* PROTOBUF_NULLABLE Report::unsafe_arena_release_docking() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robocommand.roboboat.v1.Report.docking)
  if (body_case() == kDocking) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::Docking*>(_impl_.body_.docking_);
    _impl_.body_.docking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Report::unsafe_arena_set_allocated_docking(
    ::robocommand::roboboat::v1::Docking* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_docking();
    _impl_.body_.docking_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robocommand.roboboat.v1.Report.docking)
}
inline ::robocommand::roboboat::v1::Docking* PROTOBUF_NONNULL Report::_internal_mutable_docking() {
  if (body_case() != kDocking) {
    clear_body();
    set_has_docking();
    _impl_.body_.docking_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::robocommand::roboboat::v1::Docking>(GetArena()));
  }
  return reinterpret_cast<::robocommand::roboboat::v1::Docking*>(_impl_.body_.docking_);
}
inline ::robocommand::roboboat::v1::Docking* PROTOBUF_NONNULL Report::mutable_docking()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::robocommand::roboboat::v1::Docking* _msg = _internal_mutable_docking();
  // @@protoc_insertion_point(field_mutable:robocommand.roboboat.v1.Report.docking)
  return _msg;
}

// .robocommand.roboboat.v1.SoundSignal sound_signal = 15;
inline bool Report::has_sound_signal() const {
  return body_case() == kSoundSignal;
}
inline bool Report::_internal_has_sound_signal() const {
  return body_case() == kSoundSignal;
}
inline void Report::set_has_sound_signal() {
  _impl_._oneof_case_[0] = kSoundSignal;
}
inline void Report::clear_sound_signal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kSoundSignal) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.sound_signal_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.sound_signal_);
    }
    clear_has_body();
  }
}
inline ::robocommand::roboboat::v1::SoundSignal* PROTOBUF_NULLABLE Report::release_sound_signal() {
  // @@protoc_insertion_point(field_release:robocommand.roboboat.v1.Report.sound_signal)
  if (body_case() == kSoundSignal) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::SoundSignal*>(_impl_.body_.sound_signal_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.sound_signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robocommand::roboboat::v1::SoundSignal& Report::_internal_sound_signal() const {
  return body_case() == kSoundSignal ? *reinterpret_cast<::robocommand::roboboat::v1::SoundSignal*>(_impl_.body_.sound_signal_) : reinterpret_cast<::robocommand::roboboat::v1::SoundSignal&>(::robocommand::roboboat::v1::_SoundSignal_default_instance_);
}
inline const ::robocommand::roboboat::v1::SoundSignal& Report::sound_signal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Report.sound_signal)
  return _internal_sound_signal();
}
inline ::robocommand::roboboat::v1::SoundSignal* PROTOBUF_NULLABLE Report::unsafe_arena_release_sound_signal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robocommand.roboboat.v1.Report.sound_signal)
  if (body_case() == kSoundSignal) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::SoundSignal*>(_impl_.body_.sound_signal_);
    _impl_.body_.sound_signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Report::unsafe_arena_set_allocated_sound_signal(
    ::robocommand::roboboat::v1::SoundSignal* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_sound_signal();
    _impl_.body_.sound_signal_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robocommand.roboboat.v1.Report.sound_signal)
}
inline ::robocommand::roboboat::v1::SoundSignal* PROTOBUF_NONNULL Report::_internal_mutable_sound_signal() {
  if (body_case() != kSoundSignal) {
    clear_body();
    set_has_sound_signal();
    _impl_.body_.sound_signal_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::robocommand::roboboat::v1::SoundSignal>(GetArena()));
  }
  return reinterpret_cast<::robocommand::roboboat::v1::SoundSignal*>(_impl_.body_.sound_signal_);
}
inline ::robocommand::roboboat::v1::SoundSignal* PROTOBUF_NONNULL Report::mutable_sound_signal()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::robocommand::roboboat::v1::SoundSignal* _msg = _internal_mutable_sound_signal();
  // @@protoc_insertion_point(field_mutable:robocommand.roboboat.v1.Report.sound_signal)
  return _msg;
}

// .robocommand.roboboat.v1.PatrolBoat patrol_boat = 16;
inline bool Report::has_patrol_boat() const {
  return body_case() == kPatrolBoat;
}
inline bool Report::_internal_has_patrol_boat() const {
  return body_case() == kPatrolBoat;
}
inline void Report::set_has_patrol_boat() {
  _impl_._oneof_case_[0] = kPatrolBoat;
}
inline void Report::clear_patrol_boat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kPatrolBoat) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.patrol_boat_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.patrol_boat_);
    }
    clear_has_body();
  }
}
inline ::robocommand::roboboat::v1::PatrolBoat* PROTOBUF_NULLABLE Report::release_patrol_boat() {
  // @@protoc_insertion_point(field_release:robocommand.roboboat.v1.Report.patrol_boat)
  if (body_case() == kPatrolBoat) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::PatrolBoat*>(_impl_.body_.patrol_boat_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.patrol_boat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robocommand::roboboat::v1::PatrolBoat& Report::_internal_patrol_boat() const {
  return body_case() == kPatrolBoat ? *reinterpret_cast<::robocommand::roboboat::v1::PatrolBoat*>(_impl_.body_.patrol_boat_) : reinterpret_cast<::robocommand::roboboat::v1::PatrolBoat&>(::robocommand::roboboat::v1::_PatrolBoat_default_instance_);
}
inline const ::robocommand::roboboat::v1::PatrolBoat& Report::patrol_boat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Report.patrol_boat)
  return _internal_patrol_boat();
}
inline ::robocommand::roboboat::v1::PatrolBoat* PROTOBUF_NULLABLE Report::unsafe_arena_release_patrol_boat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robocommand.roboboat.v1.Report.patrol_boat)
  if (body_case() == kPatrolBoat) {
    clear_has_body();
    auto* temp = reinterpret_cast<::robocommand::roboboat::v1::PatrolBoat*>(_impl_.body_.patrol_boat_);
    _impl_.body_.patrol_boat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Report::unsafe_arena_set_allocated_patrol_boat(
    ::robocommand::roboboat::v1::PatrolBoat* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_patrol_boat();
    _impl_.body_.patrol_boat_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robocommand.roboboat.v1.Report.patrol_boat)
}
inline ::robocommand::roboboat::v1::PatrolBoat* PROTOBUF_NONNULL Report::_internal_mutable_patrol_boat() {
  if (body_case() != kPatrolBoat) {
    clear_body();
    set_has_patrol_boat();
    _impl_.body_.patrol_boat_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::robocommand::roboboat::v1::PatrolBoat>(GetArena()));
  }
  return reinterpret_cast<::robocommand::roboboat::v1::PatrolBoat*>(_impl_.body_.patrol_boat_);
}
inline ::robocommand::roboboat::v1::PatrolBoat* PROTOBUF_NONNULL Report::mutable_patrol_boat()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::robocommand::roboboat::v1::PatrolBoat* _msg = _internal_mutable_patrol_boat();
  // @@protoc_insertion_point(field_mutable:robocommand.roboboat.v1.Report.patrol_boat)
  return _msg;
}

inline bool Report::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void Report::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline Report::BodyCase Report::body_case() const {
  return Report::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LatLng

// double latitude = 1;
inline bool LatLng::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  return value;
}
inline void LatLng::clear_latitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline double LatLng::latitude() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.LatLng.latitude)
  return _internal_latitude();
}
inline void LatLng::set_latitude(double value) {
  _internal_set_latitude(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.LatLng.latitude)
}
inline double LatLng::_internal_latitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latitude_;
}
inline void LatLng::_internal_set_latitude(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_ = value;
}

// double longitude = 2;
inline bool LatLng::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  return value;
}
inline void LatLng::clear_longitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline double LatLng::longitude() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.LatLng.longitude)
  return _internal_longitude();
}
inline void LatLng::set_longitude(double value) {
  _internal_set_longitude(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.LatLng.longitude)
}
inline double LatLng::_internal_longitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.longitude_;
}
inline void LatLng::_internal_set_longitude(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_ = value;
}

// -------------------------------------------------------------------

// Heartbeat

// .robocommand.roboboat.v1.RobotState state = 1;
inline bool Heartbeat::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  return value;
}
inline void Heartbeat::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::robocommand::roboboat::v1::RobotState Heartbeat::state() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Heartbeat.state)
  return _internal_state();
}
inline void Heartbeat::set_state(::robocommand::roboboat::v1::RobotState value) {
  _internal_set_state(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.Heartbeat.state)
}
inline ::robocommand::roboboat::v1::RobotState Heartbeat::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::robocommand::roboboat::v1::RobotState>(_impl_.state_);
}
inline void Heartbeat::_internal_set_state(::robocommand::roboboat::v1::RobotState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// .robocommand.roboboat.v1.LatLng position = 2;
inline bool Heartbeat::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Heartbeat::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::robocommand::roboboat::v1::LatLng& Heartbeat::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::robocommand::roboboat::v1::LatLng* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::robocommand::roboboat::v1::LatLng&>(::robocommand::roboboat::v1::_LatLng_default_instance_);
}
inline const ::robocommand::roboboat::v1::LatLng& Heartbeat::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Heartbeat.position)
  return _internal_position();
}
inline void Heartbeat::unsafe_arena_set_allocated_position(
    ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::robocommand::roboboat::v1::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robocommand.roboboat.v1.Heartbeat.position)
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE Heartbeat::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::robocommand::roboboat::v1::LatLng* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE Heartbeat::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:robocommand.roboboat.v1.Heartbeat.position)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::robocommand::roboboat::v1::LatLng* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL Heartbeat::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::robocommand::roboboat::v1::LatLng>(GetArena());
    _impl_.position_ = reinterpret_cast<::robocommand::roboboat::v1::LatLng*>(p);
  }
  return _impl_.position_;
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL Heartbeat::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::robocommand::roboboat::v1::LatLng* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:robocommand.roboboat.v1.Heartbeat.position)
  return _msg;
}
inline void Heartbeat::set_allocated_position(::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.position_ = reinterpret_cast<::robocommand::roboboat::v1::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:robocommand.roboboat.v1.Heartbeat.position)
}

// float spd_mps = 3;
inline bool Heartbeat::has_spd_mps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004U) != 0;
  return value;
}
inline void Heartbeat::clear_spd_mps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spd_mps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline float Heartbeat::spd_mps() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Heartbeat.spd_mps)
  return _internal_spd_mps();
}
inline void Heartbeat::set_spd_mps(float value) {
  _internal_set_spd_mps(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.Heartbeat.spd_mps)
}
inline float Heartbeat::_internal_spd_mps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spd_mps_;
}
inline void Heartbeat::_internal_set_spd_mps(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spd_mps_ = value;
}

// float heading_deg = 4;
inline bool Heartbeat::has_heading_deg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008U) != 0;
  return value;
}
inline void Heartbeat::clear_heading_deg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.heading_deg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline float Heartbeat::heading_deg() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Heartbeat.heading_deg)
  return _internal_heading_deg();
}
inline void Heartbeat::set_heading_deg(float value) {
  _internal_set_heading_deg(value);
  _impl_._has_bits_[0] |= 0x00000008U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.Heartbeat.heading_deg)
}
inline float Heartbeat::_internal_heading_deg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.heading_deg_;
}
inline void Heartbeat::_internal_set_heading_deg(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.heading_deg_ = value;
}

// .robocommand.roboboat.v1.TaskType current_task = 5;
inline bool Heartbeat::has_current_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010U) != 0;
  return value;
}
inline void Heartbeat::clear_current_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_task_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010U;
}
inline ::robocommand::roboboat::v1::TaskType Heartbeat::current_task() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Heartbeat.current_task)
  return _internal_current_task();
}
inline void Heartbeat::set_current_task(::robocommand::roboboat::v1::TaskType value) {
  _internal_set_current_task(value);
  _impl_._has_bits_[0] |= 0x00000010U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.Heartbeat.current_task)
}
inline ::robocommand::roboboat::v1::TaskType Heartbeat::_internal_current_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::robocommand::roboboat::v1::TaskType>(_impl_.current_task_);
}
inline void Heartbeat::_internal_set_current_task(::robocommand::roboboat::v1::TaskType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_task_ = value;
}

// -------------------------------------------------------------------

// ObjectDetected

// .robocommand.roboboat.v1.ObjectType object_type = 1;
inline bool ObjectDetected::has_object_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  return value;
}
inline void ObjectDetected::clear_object_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.object_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::robocommand::roboboat::v1::ObjectType ObjectDetected::object_type() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.ObjectDetected.object_type)
  return _internal_object_type();
}
inline void ObjectDetected::set_object_type(::robocommand::roboboat::v1::ObjectType value) {
  _internal_set_object_type(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.ObjectDetected.object_type)
}
inline ::robocommand::roboboat::v1::ObjectType ObjectDetected::_internal_object_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::robocommand::roboboat::v1::ObjectType>(_impl_.object_type_);
}
inline void ObjectDetected::_internal_set_object_type(::robocommand::roboboat::v1::ObjectType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.object_type_ = value;
}

// .robocommand.roboboat.v1.Color color = 2;
inline bool ObjectDetected::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004U) != 0;
  return value;
}
inline void ObjectDetected::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::robocommand::roboboat::v1::Color ObjectDetected::color() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.ObjectDetected.color)
  return _internal_color();
}
inline void ObjectDetected::set_color(::robocommand::roboboat::v1::Color value) {
  _internal_set_color(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.ObjectDetected.color)
}
inline ::robocommand::roboboat::v1::Color ObjectDetected::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::robocommand::roboboat::v1::Color>(_impl_.color_);
}
inline void ObjectDetected::_internal_set_color(::robocommand::roboboat::v1::Color value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = value;
}

// .robocommand.roboboat.v1.LatLng position = 3;
inline bool ObjectDetected::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void ObjectDetected::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::robocommand::roboboat::v1::LatLng& ObjectDetected::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::robocommand::roboboat::v1::LatLng* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::robocommand::roboboat::v1::LatLng&>(::robocommand::roboboat::v1::_LatLng_default_instance_);
}
inline const ::robocommand::roboboat::v1::LatLng& ObjectDetected::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.ObjectDetected.position)
  return _internal_position();
}
inline void ObjectDetected::unsafe_arena_set_allocated_position(
    ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::robocommand::roboboat::v1::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robocommand.roboboat.v1.ObjectDetected.position)
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE ObjectDetected::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::robocommand::roboboat::v1::LatLng* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE ObjectDetected::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:robocommand.roboboat.v1.ObjectDetected.position)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::robocommand::roboboat::v1::LatLng* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL ObjectDetected::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::robocommand::roboboat::v1::LatLng>(GetArena());
    _impl_.position_ = reinterpret_cast<::robocommand::roboboat::v1::LatLng*>(p);
  }
  return _impl_.position_;
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL ObjectDetected::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::robocommand::roboboat::v1::LatLng* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:robocommand.roboboat.v1.ObjectDetected.position)
  return _msg;
}
inline void ObjectDetected::set_allocated_position(::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.position_ = reinterpret_cast<::robocommand::roboboat::v1::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:robocommand.roboboat.v1.ObjectDetected.position)
}

// uint32 object_id = 4;
inline bool ObjectDetected::has_object_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008U) != 0;
  return value;
}
inline void ObjectDetected::clear_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.object_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline ::uint32_t ObjectDetected::object_id() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.ObjectDetected.object_id)
  return _internal_object_id();
}
inline void ObjectDetected::set_object_id(::uint32_t value) {
  _internal_set_object_id(value);
  _impl_._has_bits_[0] |= 0x00000008U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.ObjectDetected.object_id)
}
inline ::uint32_t ObjectDetected::_internal_object_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.object_id_;
}
inline void ObjectDetected::_internal_set_object_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.object_id_ = value;
}

// .robocommand.roboboat.v1.TaskType task_context = 5;
inline bool ObjectDetected::has_task_context() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010U) != 0;
  return value;
}
inline void ObjectDetected::clear_task_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_context_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010U;
}
inline ::robocommand::roboboat::v1::TaskType ObjectDetected::task_context() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.ObjectDetected.task_context)
  return _internal_task_context();
}
inline void ObjectDetected::set_task_context(::robocommand::roboboat::v1::TaskType value) {
  _internal_set_task_context(value);
  _impl_._has_bits_[0] |= 0x00000010U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.ObjectDetected.task_context)
}
inline ::robocommand::roboboat::v1::TaskType ObjectDetected::_internal_task_context() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::robocommand::roboboat::v1::TaskType>(_impl_.task_context_);
}
inline void ObjectDetected::_internal_set_task_context(::robocommand::roboboat::v1::TaskType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_context_ = value;
}

// -------------------------------------------------------------------

// GatePass

// .robocommand.roboboat.v1.GateType type = 1;
inline bool GatePass::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  return value;
}
inline void GatePass::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::robocommand::roboboat::v1::GateType GatePass::type() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.GatePass.type)
  return _internal_type();
}
inline void GatePass::set_type(::robocommand::roboboat::v1::GateType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.GatePass.type)
}
inline ::robocommand::roboboat::v1::GateType GatePass::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::robocommand::roboboat::v1::GateType>(_impl_.type_);
}
inline void GatePass::_internal_set_type(::robocommand::roboboat::v1::GateType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .robocommand.roboboat.v1.LatLng position = 2;
inline bool GatePass::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void GatePass::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::robocommand::roboboat::v1::LatLng& GatePass::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::robocommand::roboboat::v1::LatLng* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::robocommand::roboboat::v1::LatLng&>(::robocommand::roboboat::v1::_LatLng_default_instance_);
}
inline const ::robocommand::roboboat::v1::LatLng& GatePass::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.GatePass.position)
  return _internal_position();
}
inline void GatePass::unsafe_arena_set_allocated_position(
    ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::robocommand::roboboat::v1::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robocommand.roboboat.v1.GatePass.position)
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE GatePass::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::robocommand::roboboat::v1::LatLng* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE GatePass::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:robocommand.roboboat.v1.GatePass.position)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::robocommand::roboboat::v1::LatLng* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL GatePass::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::robocommand::roboboat::v1::LatLng>(GetArena());
    _impl_.position_ = reinterpret_cast<::robocommand::roboboat::v1::LatLng*>(p);
  }
  return _impl_.position_;
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL GatePass::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::robocommand::roboboat::v1::LatLng* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:robocommand.roboboat.v1.GatePass.position)
  return _msg;
}
inline void GatePass::set_allocated_position(::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.position_ = reinterpret_cast<::robocommand::roboboat::v1::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:robocommand.roboboat.v1.GatePass.position)
}

// -------------------------------------------------------------------

// ObjectDelivery

// .robocommand.roboboat.v1.Color vessel_color = 1;
inline bool ObjectDelivery::has_vessel_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  return value;
}
inline void ObjectDelivery::clear_vessel_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vessel_color_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::robocommand::roboboat::v1::Color ObjectDelivery::vessel_color() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.ObjectDelivery.vessel_color)
  return _internal_vessel_color();
}
inline void ObjectDelivery::set_vessel_color(::robocommand::roboboat::v1::Color value) {
  _internal_set_vessel_color(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.ObjectDelivery.vessel_color)
}
inline ::robocommand::roboboat::v1::Color ObjectDelivery::_internal_vessel_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::robocommand::roboboat::v1::Color>(_impl_.vessel_color_);
}
inline void ObjectDelivery::_internal_set_vessel_color(::robocommand::roboboat::v1::Color value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vessel_color_ = value;
}

// .robocommand.roboboat.v1.LatLng position = 2;
inline bool ObjectDelivery::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void ObjectDelivery::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::robocommand::roboboat::v1::LatLng& ObjectDelivery::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::robocommand::roboboat::v1::LatLng* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::robocommand::roboboat::v1::LatLng&>(::robocommand::roboboat::v1::_LatLng_default_instance_);
}
inline const ::robocommand::roboboat::v1::LatLng& ObjectDelivery::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.ObjectDelivery.position)
  return _internal_position();
}
inline void ObjectDelivery::unsafe_arena_set_allocated_position(
    ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::robocommand::roboboat::v1::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robocommand.roboboat.v1.ObjectDelivery.position)
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE ObjectDelivery::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::robocommand::roboboat::v1::LatLng* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE ObjectDelivery::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:robocommand.roboboat.v1.ObjectDelivery.position)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::robocommand::roboboat::v1::LatLng* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL ObjectDelivery::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::robocommand::roboboat::v1::LatLng>(GetArena());
    _impl_.position_ = reinterpret_cast<::robocommand::roboboat::v1::LatLng*>(p);
  }
  return _impl_.position_;
}
inline ::robocommand::roboboat::v1::LatLng* PROTOBUF_NONNULL ObjectDelivery::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::robocommand::roboboat::v1::LatLng* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:robocommand.roboboat.v1.ObjectDelivery.position)
  return _msg;
}
inline void ObjectDelivery::set_allocated_position(::robocommand::roboboat::v1::LatLng* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.position_ = reinterpret_cast<::robocommand::roboboat::v1::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:robocommand.roboboat.v1.ObjectDelivery.position)
}

// .robocommand.roboboat.v1.DeliveryType delivery_type = 3;
inline bool ObjectDelivery::has_delivery_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004U) != 0;
  return value;
}
inline void ObjectDelivery::clear_delivery_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delivery_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::robocommand::roboboat::v1::DeliveryType ObjectDelivery::delivery_type() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.ObjectDelivery.delivery_type)
  return _internal_delivery_type();
}
inline void ObjectDelivery::set_delivery_type(::robocommand::roboboat::v1::DeliveryType value) {
  _internal_set_delivery_type(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.ObjectDelivery.delivery_type)
}
inline ::robocommand::roboboat::v1::DeliveryType ObjectDelivery::_internal_delivery_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::robocommand::roboboat::v1::DeliveryType>(_impl_.delivery_type_);
}
inline void ObjectDelivery::_internal_set_delivery_type(::robocommand::roboboat::v1::DeliveryType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delivery_type_ = value;
}

// -------------------------------------------------------------------

// Docking

// string dock = 1;
inline bool Docking::has_dock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  return value;
}
inline void Docking::clear_dock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dock_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::absl::string_view Docking::dock() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Docking.dock)
  return _internal_dock();
}
template <typename Arg_>
PROTOBUF_ALWAYS_INLINE void Docking::set_dock(Arg_&& arg) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.dock_.Set(static_cast<Arg_&&>(arg), GetArena());
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.Docking.dock)
}
inline ::absl::string_view Docking::_internal_dock() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dock_.Get();
}
inline void Docking::_internal_set_dock(::absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.dock_.Set(value, GetArena());
}

// string slip = 2;
inline bool Docking::has_slip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  return value;
}
inline void Docking::clear_slip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::absl::string_view Docking::slip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.Docking.slip)
  return _internal_slip();
}
template <typename Arg_>
PROTOBUF_ALWAYS_INLINE void Docking::set_slip(Arg_&& arg) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.slip_.Set(static_cast<Arg_&&>(arg), GetArena());
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.Docking.slip)
}
inline ::absl::string_view Docking::_internal_slip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slip_.Get();
}
inline void Docking::_internal_set_slip(::absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.slip_.Set(value, GetArena());
}

// -------------------------------------------------------------------

// SoundSignal

// .robocommand.roboboat.v1.SignalType signal_type = 1;
inline bool SoundSignal::has_signal_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  return value;
}
inline void SoundSignal::clear_signal_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signal_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::robocommand::roboboat::v1::SignalType SoundSignal::signal_type() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.SoundSignal.signal_type)
  return _internal_signal_type();
}
inline void SoundSignal::set_signal_type(::robocommand::roboboat::v1::SignalType value) {
  _internal_set_signal_type(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.SoundSignal.signal_type)
}
inline ::robocommand::roboboat::v1::SignalType SoundSignal::_internal_signal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::robocommand::roboboat::v1::SignalType>(_impl_.signal_type_);
}
inline void SoundSignal::_internal_set_signal_type(::robocommand::roboboat::v1::SignalType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signal_type_ = value;
}

// uint32 frequency_hz = 2;
inline bool SoundSignal::has_frequency_hz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  return value;
}
inline void SoundSignal::clear_frequency_hz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frequency_hz_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t SoundSignal::frequency_hz() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.SoundSignal.frequency_hz)
  return _internal_frequency_hz();
}
inline void SoundSignal::set_frequency_hz(::uint32_t value) {
  _internal_set_frequency_hz(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.SoundSignal.frequency_hz)
}
inline ::uint32_t SoundSignal::_internal_frequency_hz() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frequency_hz_;
}
inline void SoundSignal::_internal_set_frequency_hz(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frequency_hz_ = value;
}

// .robocommand.roboboat.v1.TaskType assigned_task = 3;
inline bool SoundSignal::has_assigned_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004U) != 0;
  return value;
}
inline void SoundSignal::clear_assigned_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_task_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::robocommand::roboboat::v1::TaskType SoundSignal::assigned_task() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.SoundSignal.assigned_task)
  return _internal_assigned_task();
}
inline void SoundSignal::set_assigned_task(::robocommand::roboboat::v1::TaskType value) {
  _internal_set_assigned_task(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.SoundSignal.assigned_task)
}
inline ::robocommand::roboboat::v1::TaskType SoundSignal::_internal_assigned_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::robocommand::roboboat::v1::TaskType>(_impl_.assigned_task_);
}
inline void SoundSignal::_internal_set_assigned_task(::robocommand::roboboat::v1::TaskType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_task_ = value;
}

// -------------------------------------------------------------------

// PatrolBoat

// .robocommand.roboboat.v1.PatrolBoatActionType patrol_boat_action_type = 1;
inline bool PatrolBoat::has_patrol_boat_action_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  return value;
}
inline void PatrolBoat::clear_patrol_boat_action_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.patrol_boat_action_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::robocommand::roboboat::v1::PatrolBoatActionType PatrolBoat::patrol_boat_action_type() const {
  // @@protoc_insertion_point(field_get:robocommand.roboboat.v1.PatrolBoat.patrol_boat_action_type)
  return _internal_patrol_boat_action_type();
}
inline void PatrolBoat::set_patrol_boat_action_type(::robocommand::roboboat::v1::PatrolBoatActionType value) {
  _internal_set_patrol_boat_action_type(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:robocommand.roboboat.v1.PatrolBoat.patrol_boat_action_type)
}
inline ::robocommand::roboboat::v1::PatrolBoatActionType PatrolBoat::_internal_patrol_boat_action_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::robocommand::roboboat::v1::PatrolBoatActionType>(_impl_.patrol_boat_action_type_);
}
inline void PatrolBoat::_internal_set_patrol_boat_action_type(::robocommand::roboboat::v1::PatrolBoatActionType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.patrol_boat_action_type_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace roboboat
}  // namespace robocommand


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::robocommand::roboboat::v1::RobotState> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::robocommand::roboboat::v1::RobotState>() {
  return ::robocommand::roboboat::v1::RobotState_descriptor();
}
template <>
struct is_proto_enum<::robocommand::roboboat::v1::TaskType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::robocommand::roboboat::v1::TaskType>() {
  return ::robocommand::roboboat::v1::TaskType_descriptor();
}
template <>
struct is_proto_enum<::robocommand::roboboat::v1::ObjectType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::robocommand::roboboat::v1::ObjectType>() {
  return ::robocommand::roboboat::v1::ObjectType_descriptor();
}
template <>
struct is_proto_enum<::robocommand::roboboat::v1::Color> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::robocommand::roboboat::v1::Color>() {
  return ::robocommand::roboboat::v1::Color_descriptor();
}
template <>
struct is_proto_enum<::robocommand::roboboat::v1::GateType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::robocommand::roboboat::v1::GateType>() {
  return ::robocommand::roboboat::v1::GateType_descriptor();
}
template <>
struct is_proto_enum<::robocommand::roboboat::v1::SignalType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::robocommand::roboboat::v1::SignalType>() {
  return ::robocommand::roboboat::v1::SignalType_descriptor();
}
template <>
struct is_proto_enum<::robocommand::roboboat::v1::DeliveryType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::robocommand::roboboat::v1::DeliveryType>() {
  return ::robocommand::roboboat::v1::DeliveryType_descriptor();
}
template <>
struct is_proto_enum<::robocommand::roboboat::v1::PatrolBoatActionType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::robocommand::roboboat::v1::PatrolBoatActionType>() {
  return ::robocommand::roboboat::v1::PatrolBoatActionType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // proto_2freport_2eproto_2epb_2eh
